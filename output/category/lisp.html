<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="utf-8">
    <title>coolnet's world</title>
    <meta name="description" content="博主一个爱好开源技术的人, 对PHP比较熟悉,也喜欢用PHP捣腾一些东西, 本博主要分享一些开源技术,其中包括但不限于Linux/PHP/Vim.">
    <meta name="keywords" content="PHP, Linux, vim, 开源">
    <meta name="author" content="coolnet">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
    <script src="http://blog.me/theme/html5.js"></script>
    <![endif]-->

    <!-- Le styles -->
    <link href="http://blog.me/theme/bootstrap.min.css" rel="stylesheet">
    <link href="http://blog.me/theme/bootstrap.min.responsive.css" rel="stylesheet">
    <link href="http://blog.me/theme/local.css" rel="stylesheet">
    <link href="http://blog.me/theme/tag.css" rel="stylesheet">
    <link href="http://blog.me/theme/pygments.css" rel="stylesheet">
</head>

<body>

<div class="navbar">
    <div class="navbar-inner">
    <div class="container">

         <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
             <span class="icon-bar"></span>
             <span class="icon-bar"></span>
             <span class="icon-bar"></span>
         </a>

        <a class="brand" href="http://blog.me">coolnet's world</a>

        <div class="nav-collapse">
        <ul class="nav">
            
        </ul>
        </div>
        
    </div>
    </div>
</div>

<div class="container">
    <div class="content">
    <div class="row">

        <div class="span9">
        

        


    <div class='article'>
        <div class="content-title">
            <a href="http://blog.me/lispxue-xi-bi-ji-mian-xiang-dui-xiang.html"><h1>Lisp学习笔记: 面向对象</h1></a>
五 29 三月 2013

by <a class="url fn" href="http://blog.me/author/coolnet.html">coolnet</a>
 


 
        </div>
        
        <div><h2>DEFCLASS</h2>
<p><em>DEFCLASS</em>宏用来创建用户定义类.类关联行为是通过定义广义函数和特化在该类上的方法觉得的, <em>DEFCLASS</em>只负责将类定义为一种数据类型</p>
<p>类作为数据类型的三个方面:</p>
<ul>
<li>名字</li>
<li>与其他类的关系</li>
<li>构成该类实例的那些槽的名字</li>
</ul>
<p><em>DEFCLASS</em>的基本形式</p>
<div class="highlight"><pre><span class="p">(</span><span class="n">defclass</span> <span class="n">name</span> <span class="p">(</span><span class="n">direct</span><span class="o">-</span><span class="n">superclass</span><span class="o">-</span><span class="n">name</span><span class="o">*</span><span class="p">)</span>
  <span class="p">(</span><span class="n">slot</span><span class="o">-</span><span class="n">specifier</span><span class="o">*</span><span class="p">))</span>
</pre></div>


<p><em>MAKE-INSTANCE</em>可以将类实例化, 它使用类名作为参数</p>
<p>借类如果不指定将继承<em>STANDARD-OBJECT</em>类</p>
<h1>槽</h1>
<p><em>DEFCLASS</em>形式大部分是由槽描述符的列表组成的.每个槽描述符定义的槽都属于改类的每个实例. 实例的每个槽都可以保存值的位置, 该位置可以通过函数<em>SLOT-VALUE</em>来访问</p>
<p><em>SLOT-VALUE</em>接受一个对象和一个槽的名字作为参数并返回该对象中改命名的槽的值.它支持 <em>SETF</em>位置</p>
<p>一个类从基类中继承槽描述符</p>
<h2>对象初始化</h2>
<p>Common Lisp提供了三种方式来控制槽的初始值:
<em> 通过:initarg 选项, 你可以指定随后作为 </em>MAKE-INSTANCE<em>的关键字形参名字并使用该参数的值保存在槽中
</em> :initform可以让你指定一个Lisp表达式在没有:initarg参数传递给<em>MAKE-INSTANCE</em>时为改槽计算一个值
<em> 在广义函数</em>INITIALIZA-INSTANCE<em>上定义一个方法, 它将被</em>MAKE-INSTANCE*调用</p>
<p>下面是一个初始化例子</p>
<div class="highlight"><pre><span class="p">(</span><span class="n">defclass</span> <span class="n">bank</span><span class="o">-</span><span class="n">account</span> <span class="p">()</span>
  <span class="p">((</span><span class="n">customer</span><span class="o">-</span><span class="n">name</span>
    <span class="o">:</span><span class="n">initarg</span> <span class="o">:</span><span class="n">customer</span><span class="o">-</span><span class="n">name</span><span class="p">)</span>
  <span class="p">(</span><span class="n">balance</span>
    <span class="o">:</span><span class="n">initarg</span> <span class="o">:</span><span class="n">balance</span>
    <span class="o">:</span><span class="n">initform</span> <span class="mi">0</span><span class="p">)))</span>
</pre></div>


<p>如果实例时没有给 :customer-name关键字形参, 那么 customer-name 槽将会是未绑定</p>
<p>可以像下面定义, 要求必须给定 :customer-name参数</p>
<div class="highlight"><pre><span class="p">(</span><span class="n">defvar</span> <span class="o">*</span><span class="n">account</span><span class="o">-</span><span class="n">numbers</span><span class="o">*</span> <span class="mi">0</span><span class="p">)</span>

<span class="p">(</span><span class="n">defclass</span> <span class="n">bank</span><span class="o">-</span><span class="n">account</span> <span class="p">()</span>
  <span class="p">((</span><span class="n">customer</span><span class="o">-</span><span class="n">name</span>
    <span class="o">:</span><span class="n">initarg</span> <span class="o">:</span><span class="n">customer</span><span class="o">-</span><span class="n">name</span>
    <span class="o">:</span><span class="n">initform</span> <span class="p">(</span><span class="n">error</span> <span class="s">&quot;Must supply a customer name.&quot;</span><span class="p">))</span>
   <span class="p">(</span><span class="n">balance</span>
    <span class="o">:</span><span class="n">initarg</span> <span class="o">:</span><span class="n">balance</span>
    <span class="o">:</span><span class="n">initform</span> <span class="mi">0</span><span class="p">)</span>
   <span class="p">(</span><span class="n">account</span><span class="o">-</span><span class="n">number</span>
    <span class="o">:</span><span class="n">initform</span> <span class="p">(</span><span class="n">incf</span> <span class="o">*</span><span class="n">account</span><span class="o">-</span><span class="n">numbers</span><span class="o">*</span><span class="p">))))</span>
</pre></div>


<h3>INITIALIZE-INSTANCE</h3>
<p><em>STANDARD-OBJECT</em>上特化的 <em>INITIALIZA-INSTANCE</em>主方法负责槽的初始化工作</p>
<p>最常见的的是定义一个特化在类上的 _:after_方法</p>
<p>下面是一个例子:</p>
<div class="highlight"><pre><span class="p">(</span><span class="n">defvar</span> <span class="o">*</span><span class="n">account</span><span class="o">-</span><span class="n">numbers</span><span class="o">*</span> <span class="mi">0</span><span class="p">)</span>

<span class="p">(</span><span class="n">defclass</span> <span class="n">bank</span><span class="o">-</span><span class="n">account</span> <span class="p">()</span>
  <span class="p">((</span><span class="n">customer</span><span class="o">-</span><span class="n">name</span>
    <span class="o">:</span><span class="n">initarg</span> <span class="o">:</span><span class="n">customer</span><span class="o">-</span><span class="n">name</span>
    <span class="o">:</span><span class="n">initform</span> <span class="p">(</span><span class="n">error</span> <span class="s">&quot;Must supply a customer name.&quot;</span><span class="p">))</span>
   <span class="p">(</span><span class="n">balance</span>
    <span class="o">:</span><span class="n">initarg</span> <span class="o">:</span><span class="n">balance</span>
    <span class="o">:</span><span class="n">initform</span> <span class="mi">0</span><span class="p">)</span>
   <span class="p">(</span><span class="n">account</span><span class="o">-</span><span class="n">number</span>
    <span class="o">:</span><span class="n">initform</span> <span class="p">(</span><span class="n">incf</span> <span class="o">*</span><span class="n">account</span><span class="o">-</span><span class="n">numbers</span><span class="o">*</span><span class="p">))</span>
   <span class="n">account</span><span class="o">-</span><span class="n">type</span><span class="p">))</span>
<span class="p">;;</span> <span class="err">设置</span> <span class="n">account</span><span class="o">-</span><span class="n">type</span><span class="err">槽</span>
<span class="p">(</span><span class="n">defmethod</span> <span class="n">initialize</span><span class="o">-</span><span class="n">instance</span> <span class="o">:</span><span class="n">after</span> <span class="p">((</span><span class="n">account</span> <span class="n">bank</span><span class="o">-</span><span class="n">account</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">)</span>
  <span class="p">(</span><span class="n">let</span> <span class="p">((</span><span class="n">balance</span> <span class="p">(</span><span class="n">slot</span><span class="o">-</span><span class="n">value</span> <span class="n">account</span> <span class="err">&#39;</span><span class="n">balance</span><span class="p">)))</span>
    <span class="p">(</span><span class="n">setf</span> <span class="p">(</span><span class="n">slot</span><span class="o">-</span><span class="n">value</span> <span class="n">account</span> <span class="err">&#39;</span><span class="n">account</span><span class="o">-</span><span class="n">type</span><span class="p">)</span>
          <span class="p">(</span><span class="n">cond</span>
            <span class="p">((</span><span class="o">&gt;=</span> <span class="n">balance</span> <span class="mi">100000</span><span class="p">)</span> <span class="o">:</span><span class="n">gold</span><span class="p">)</span>
            <span class="p">((</span><span class="o">&gt;=</span> <span class="n">balance</span> <span class="mi">50000</span><span class="p">)</span> <span class="o">:</span><span class="n">silver</span><span class="p">)</span>
            <span class="p">(</span><span class="n">t</span> <span class="o">:</span><span class="n">bronze</span><span class="p">)))))</span>
</pre></div>


<p>为了保持该方法的形参列表与广义函数一致, 形参列表中的<em>&amp;key</em>是必不可少的</p>
<h2>访问函数</h2>
<p>通过<em>SLOT-VALUE</em>很容易定义一个函数来读取槽的值</p>
<div class="highlight"><pre><span class="p">(</span><span class="n">defun</span> <span class="n">balance</span> <span class="p">(</span><span class="n">account</span><span class="p">)</span>
  <span class="p">(</span><span class="n">slot</span><span class="o">-</span><span class="n">value</span> <span class="n">account</span> <span class="err">&#39;</span><span class="n">balance</span><span class="p">))</span>
</pre></div>


<p>更好的方法是使用广义函数, 这样为子类提供了不同的方法或使用附加方法来扩展其定义</p>
<div class="highlight"><pre><span class="p">(</span><span class="n">defgeneric</span> <span class="n">balance</span> <span class="p">(</span><span class="n">account</span><span class="p">))</span>

<span class="p">(</span><span class="n">defmethod</span> <span class="n">balance</span> <span class="p">((</span><span class="n">account</span> <span class="n">bank</span><span class="o">-</span><span class="n">account</span><span class="p">))</span>
  <span class="p">(</span><span class="n">slot</span><span class="o">-</span><span class="n">value</span> <span class="n">account</span> <span class="err">&#39;</span><span class="n">balance</span><span class="p">))</span>
</pre></div>


<p>更简洁的方式是定以<em>SETF</em>函数, <em>SETF</em>函数是一种扩展<em>SETF</em>的方式, 其定义了一个新的位置类型使其知道如何设置它.<em>SETF</em>函数的名字是一个亮元素列表, 其中第一个元素是符号setf而跌入个元素是一个符号, 通常是一个用来访问改<em>SETF</em>函数将要设置的位置的函数名.<em>SETF</em>函数可以接受任何数量的参数, 但第一个参数总是赋值的位置上的值.</p>
<div class="highlight"><pre><span class="p">(</span><span class="n">defun</span> <span class="p">(</span><span class="n">setf</span> <span class="n">customer</span><span class="o">-</span><span class="n">name</span><span class="p">)</span> <span class="p">(</span><span class="n">name</span> <span class="n">account</span><span class="p">)</span>
  <span class="p">(</span><span class="n">setf</span> <span class="p">(</span><span class="n">slot</span><span class="o">-</span><span class="n">value</span> <span class="n">account</span> <span class="err">&#39;</span><span class="n">customer</span><span class="o">-</span><span class="n">name</span><span class="p">)</span> <span class="n">name</span><span class="p">))</span>
</pre></div>


<p>可以使用下面调用</p>
<div class="highlight"><pre><span class="p">(</span><span class="n">setf</span> <span class="p">(</span><span class="n">customer</span><span class="o">-</span><span class="n">name</span> <span class="n">my</span><span class="o">-</span><span class="n">account</span><span class="p">)</span> <span class="s">&quot;Sally Sue&quot;</span><span class="p">)</span>
</pre></div>


<p>上面表达式将被编译成一个对你刚刚定义的<em>SETF</em>函数的调用, 其中 "Sally Sue"作为第一个参数而my-account 的值作为第二个参数</p>
<p>可以定义广义的<em>SETF</em>函数:</p>
<div class="highlight"><pre><span class="p">(</span><span class="n">defgeneric</span> <span class="p">(</span><span class="n">setf</span> <span class="n">customer</span><span class="o">-</span><span class="n">name</span><span class="p">)</span> <span class="p">(</span><span class="n">value</span> <span class="n">account</span><span class="p">))</span>

<span class="p">(</span><span class="n">defmethod</span> <span class="p">(</span><span class="n">setf</span> <span class="n">customer</span><span class="o">-</span><span class="n">name</span><span class="p">)</span> <span class="p">(</span><span class="n">value</span> <span class="p">(</span><span class="n">account</span> <span class="n">bank</span><span class="o">-</span><span class="n">account</span><span class="p">))</span>
  <span class="p">(</span><span class="n">setf</span> <span class="p">(</span><span class="n">slot</span><span class="o">-</span><span class="n">value</span> <span class="n">account</span> <span class="err">&#39;</span><span class="n">customer</span><span class="o">-</span><span class="n">name</span><span class="p">)</span> <span class="n">value</span><span class="p">))</span>
</pre></div>


<p>也可以为 customer-name定义一个读取函数</p>
<div class="highlight"><pre><span class="p">(</span><span class="n">defgeneric</span> <span class="n">customer</span><span class="o">-</span><span class="n">name</span> <span class="p">(</span><span class="n">account</span><span class="p">))</span>

<span class="p">(</span><span class="n">defmethod</span> <span class="n">customer</span><span class="o">-</span><span class="n">name</span> <span class="p">((</span><span class="n">account</span> <span class="n">bank</span><span class="o">-</span><span class="n">account</span><span class="p">))</span>
  <span class="p">(</span><span class="n">slot</span><span class="o">-</span><span class="n">value</span> <span class="n">account</span> <span class="err">&#39;</span><span class="n">customer</span><span class="o">-</span><span class="n">name</span><span class="p">))</span>
</pre></div>


<p>根据上面代码可以写出如下表达式</p>
<div class="highlight"><pre><span class="p">(</span><span class="n">setf</span> <span class="p">(</span><span class="n">customer</span><span class="o">-</span><span class="n">name</span> <span class="o">*</span><span class="n">account</span><span class="o">*</span><span class="p">)</span> <span class="s">&quot;Sally Sue&quot;</span><span class="p">)</span>

<span class="p">(</span><span class="n">customer</span><span class="o">-</span><span class="n">name</span> <span class="o">*</span><span class="n">account</span><span class="o">*</span><span class="p">)</span>
</pre></div>


<p>收工编写与Lisp风格不太温和, <em>DEFCLASS</em>提供了三个槽选项, 自动的为特定槽创建读取和写入函数.</p>
<ul>
<li><em>:reader</em> 选项指定广义函数的名字, 该函数只接受一个对象参数.当<em>DEFCLASS</em>被求值时, 如果广义函数不存在则创建它, 然后添加一个方法, 该方法基于新类特化一个参数并返回该槽的值.该名字可以是任意的, 但通常将其命名成与槽本身相同的名字</li>
</ul>
<div class="highlight"><pre><span class="p">(</span><span class="n">balance</span>
 <span class="o">:</span><span class="n">initarg</span> <span class="o">:</span><span class="n">balance</span>
 <span class="o">:</span><span class="n">initform</span> <span class="mi">0</span>
 <span class="o">:</span><span class="n">reader</span> <span class="n">balance</span><span class="p">)</span>
</pre></div>


<ul>
<li><em>:writer</em> 选项用来创建设置一个槽的值的广义函数和方法.该函数和方法按照<em>SETF</em>函数的要求创建, 接受新值作为其第一个参数并把它作为结果返回.</li>
</ul>
<div class="highlight"><pre><span class="p">(</span><span class="n">customer</span><span class="o">-</span><span class="n">name</span>
 <span class="o">:</span><span class="n">initarg</span> <span class="o">:</span><span class="n">customer</span><span class="o">-</span><span class="n">name</span>
 <span class="o">:</span><span class="n">initform</span> <span class="p">(</span><span class="n">error</span> <span class="s">&quot;Must supply a customer name.&quot;</span><span class="p">)</span>
 <span class="o">:</span><span class="n">reader</span> <span class="n">customer</span><span class="o">-</span><span class="n">name</span>
 <span class="o">:</span><span class="n">writer</span> <span class="p">(</span><span class="n">setf</span> <span class="n">customer</span><span class="o">-</span><span class="n">name</span><span class="p">))</span>
</pre></div>


<ul>
<li><em>:accessor</em> 选项用来同时创建读取函数和对应的<em>SETF</em>函数.</li>
</ul>
<div class="highlight"><pre><span class="p">(</span><span class="n">customer</span><span class="o">-</span><span class="n">name</span>
 <span class="o">:</span><span class="n">initarg</span> <span class="o">:</span><span class="n">customer</span><span class="o">-</span><span class="n">name</span>
 <span class="o">:</span><span class="n">initform</span> <span class="p">(</span><span class="n">error</span> <span class="s">&quot;Must supply a customer name.&quot;</span><span class="p">)</span>
 <span class="o">:</span><span class="n">accessor</span> <span class="n">customer</span><span class="o">-</span><span class="n">name</span><span class="p">)</span>
</pre></div>


<p>根据上面重新定义 _bank-account_类</p>
<div class="highlight"><pre><span class="p">(</span><span class="n">defclass</span> <span class="n">bank</span><span class="o">-</span><span class="n">account</span> <span class="p">()</span>
  <span class="p">((</span><span class="n">customer</span><span class="o">-</span><span class="n">name</span>
    <span class="o">:</span><span class="n">initarg</span> <span class="o">:</span><span class="n">customer</span><span class="o">-</span><span class="n">name</span>
    <span class="o">:</span><span class="n">initform</span> <span class="p">(</span><span class="n">error</span> <span class="s">&quot;Must supply a customer name.&quot;</span><span class="p">)</span>
    <span class="o">:</span><span class="n">accessor</span> <span class="n">customer</span><span class="o">-</span><span class="n">name</span>
    <span class="o">:</span><span class="n">documentation</span> <span class="s">&quot;Customer&#39;s name&quot;</span><span class="p">)</span>
   <span class="p">(</span><span class="n">balance</span>
    <span class="o">:</span><span class="n">initarg</span> <span class="o">:</span><span class="n">balance</span>
    <span class="o">:</span><span class="n">initform</span> <span class="mi">0</span>
    <span class="o">:</span><span class="n">reader</span> <span class="n">balance</span>
    <span class="o">:</span><span class="n">documentation</span> <span class="s">&quot;Current account balance&quot;</span><span class="p">)</span>
   <span class="p">(</span><span class="n">account</span><span class="o">-</span><span class="n">number</span>
    <span class="o">:</span><span class="n">initform</span> <span class="p">(</span><span class="n">incf</span> <span class="o">*</span><span class="n">account</span><span class="o">-</span><span class="n">numbers</span><span class="o">*</span><span class="p">)</span>
    <span class="o">:</span><span class="n">reader</span> <span class="n">account</span><span class="o">-</span><span class="n">number</span>
    <span class="o">:</span><span class="n">documentation</span> <span class="s">&quot;Account number, unique within a bank.&quot;</span><span class="p">)</span>
   <span class="p">(</span><span class="n">account</span><span class="o">-</span><span class="n">type</span>
    <span class="o">:</span><span class="n">reader</span> <span class="n">account</span><span class="o">-</span><span class="n">type</span>
    <span class="o">:</span><span class="n">documentation</span> <span class="s">&quot;Type of account, one of :gold, :slver, or :bronze.&quot;</span><span class="p">)))</span>
</pre></div>


<h2>WITH-SLOTS 和 WITH-ACCESSORS</h2>
<p>两个标准宏 <em>WITH-SLOTS</em> 和 <em>WITH-ACCESSORS</em>可以减轻调用槽的混乱.</p>
<p><em>WITH-SLOTS</em>提供了对槽的直接访问, 就像<em>SLOT-VALUE</em>那样, 形式如下:</p>
<div class="highlight"><pre><span class="p">(</span><span class="n">with</span><span class="o">-</span><span class="n">slots</span> <span class="p">(</span><span class="n">slot</span><span class="o">*</span><span class="p">)</span> <span class="n">instance</span><span class="o">-</span><span class="n">form</span>
  <span class="n">body</span><span class="o">-</span><span class="n">form</span><span class="o">*</span><span class="p">)</span>
</pre></div>


<p>每一个 _slot_元素可以是一个槽的名字, 它也用作一个变量名;以个两元素列表, 第一个元素是一个用作变量的名字, 第二个元素则对应槽的名字. _instance-form_被求值依次来产生要访问其槽的对象</p>
<div class="highlight"><pre><span class="p">(</span><span class="n">defmethod</span> <span class="n">access</span><span class="o">-</span><span class="n">low</span><span class="o">-</span><span class="n">balance</span><span class="o">-</span><span class="n">penalty</span> <span class="p">((</span><span class="n">account</span> <span class="n">bank</span><span class="o">-</span><span class="n">account</span><span class="p">))</span>
  <span class="p">(</span><span class="n">with</span><span class="o">-</span><span class="n">slots</span> <span class="p">(</span><span class="n">balance</span><span class="p">)</span> <span class="n">account</span>
    <span class="p">(</span><span class="n">when</span> <span class="p">(</span><span class="o">&lt;</span> <span class="n">balance</span> <span class="o">*</span><span class="n">minium</span><span class="o">-</span><span class="n">balance</span><span class="o">*</span><span class="p">)</span>
      <span class="p">(</span><span class="n">decf</span> <span class="n">balance</span> <span class="p">(</span><span class="o">*</span> <span class="n">balance</span> <span class="mf">.01</span><span class="p">)))))</span>
</pre></div>


<p>或者使用两元素列表:</p>
<div class="highlight"><pre><span class="p">(</span><span class="n">defmethod</span> <span class="n">access</span><span class="o">-</span><span class="n">low</span><span class="o">-</span><span class="n">balance</span><span class="o">-</span><span class="n">penalty</span> <span class="p">((</span><span class="n">account</span> <span class="n">bank</span><span class="o">-</span><span class="n">account</span><span class="p">))</span>
  <span class="p">(</span><span class="n">with</span><span class="o">-</span><span class="n">slots</span> <span class="p">((</span><span class="n">bal</span> <span class="n">balance</span><span class="p">))</span> <span class="n">account</span>
    <span class="p">(</span><span class="n">when</span> <span class="p">(</span><span class="o">&lt;</span> <span class="n">balance</span> <span class="o">*</span><span class="n">minium</span><span class="o">-</span><span class="n">balance</span><span class="o">*</span><span class="p">)</span>
      <span class="p">(</span><span class="n">decf</span> <span class="n">balance</span> <span class="p">(</span><span class="o">*</span> <span class="n">balance</span> <span class="mf">.01</span><span class="p">)))))</span>
</pre></div>


<p><em>WITH-ACCESSORS</em> 提供了一个访问方法的简单方法</p>
<p>如果你已经用了一个 <em>:accessor_而不只是 </em>:reader_定义了balance, 那么可以使用<em>WITH-ACCESSORS</em>, 它和 <em>WITH-SLOTS</em>形式相同, 除了槽列表的每一项都必须包含一个变量名和一个访问函数名字的两元素列表, 在<em>WITH-ACCESSORS</em>的主体中, 对一个变量的引用等价的对应相应的访问函数调用.</p>
<div class="highlight"><pre><span class="p">(</span><span class="n">defmethod</span> <span class="n">access</span><span class="o">-</span><span class="n">low</span><span class="o">-</span><span class="n">balance</span><span class="o">-</span><span class="n">penalty</span> <span class="p">((</span><span class="n">account</span> <span class="n">bank</span><span class="o">-</span><span class="n">account</span><span class="p">))</span>
  <span class="p">(</span><span class="n">with</span><span class="o">-</span><span class="n">accessors</span> <span class="p">((</span><span class="n">balance</span> <span class="n">balance</span><span class="p">))</span> <span class="n">account</span>
    <span class="p">(</span><span class="n">when</span> <span class="p">(</span><span class="o">&lt;</span> <span class="n">balance</span> <span class="o">*</span><span class="n">minimum</span><span class="o">-</span><span class="n">balance</span><span class="o">*</span><span class="p">)</span>
      <span class="p">(</span><span class="n">decf</span> <span class="n">balance</span> <span class="p">(</span><span class="o">*</span> <span class="n">balance</span> <span class="mf">.01</span><span class="p">)))))</span>
</pre></div>


<p>上面代码中第一个balance是变量的名字, 第二个是访问函数的名字, 它们不必相同.例如和编写方法来合并两个帐号</p>
<div class="highlight"><pre><span class="p">(</span><span class="n">defmethod</span> <span class="n">merge</span><span class="o">-</span><span class="n">accounts</span> <span class="p">((</span><span class="n">account1</span> <span class="n">bank</span><span class="o">-</span><span class="n">account</span><span class="p">)</span> <span class="p">(</span><span class="n">account2</span> <span class="n">bank</span><span class="o">-</span><span class="n">account</span><span class="p">))</span>
  <span class="p">(</span><span class="n">with</span><span class="o">-</span><span class="n">accessors</span> <span class="p">((</span><span class="n">balance1</span> <span class="n">balance</span><span class="p">))</span> <span class="n">account</span> <span class="mi">1</span>
    <span class="p">(</span><span class="n">with</span><span class="o">-</span><span class="n">accessors</span> <span class="p">((</span><span class="n">balance2</span> <span class="n">balance</span><span class="p">))</span> <span class="n">account</span> <span class="mi">2</span>
      <span class="p">(</span><span class="n">incf</span> <span class="n">balance1</span> <span class="n">balance</span> <span class="mi">2</span><span class="p">)</span>
      <span class="p">(</span><span class="n">setf</span> <span class="n">balance2</span> <span class="mi">0</span><span class="p">))))</span>
</pre></div>


<h2>分配在类上的槽</h2>
<p>最后一个槽选项是 <em>:allocation</em>. 它的值可以是 <em>:instance_或 </em>:class_,默认是 <em>:instance</em>. 当一个槽带有 <em>:class_分配选项时, 该槽只有单一值存储在类中, 并且被所有实例所共享,并同样使用 <em>SLOT-VALUE</em>对 </em>:class_槽进行访问,</p>
<p><em>:class_槽也同样通过该类的一个实例来访问该槽的值, 尽管它实际并没有保存在实例中. </em>:initform_ 和 <em>:initarg_选项质上具有相同效果, 只是 </em>:initform_将在类定义时而不是每次创建实例时求值, 另一方面, 传递 _:initarg_给 <em>MAKE-INSTANCE</em>会设置该值, 从而影响该类所有实例</p></div>
        <hr />
    </div>
		

 
        

 

    <div class='article'>
        <a href="http://blog.me/lispxue-xi-bi-ji-yan-yi-han-shu.html"><h2>Lisp学习笔记: 广义函数</h2></a>
        <div class= "well small"> 五 29 三月 2013

by <a class="url fn" href="http://blog.me/author/coolnet.html">coolnet</a>
 


 </div>
        <div class="summary"><p>广义函数就是通过使用不同的参数类型来实现可以同名函数的机制, 类似C++的方法重载</p>
<h2>定义</h2>
<p><em>DEFGENERIC</em>用于定义广义函数, 该定义不产生任何实际代码, 并且它可以接受任何对象作为参数.</p>
<p>广义函数的实际实现是由方法提供, 每一个方法提供广义函数用于特定参数类的实现, 方法通过特化那些由广义函数所定义的比较参数, 来表达它们可以处理的参数类型</p>
<h2>DEFGENERIC</h2>
<p><em>DEFGENERIC</em>用于定义广义函数, 与<em>DEFUN</em>相似. <em>DEFGENERIC</em>的形参列表指定了那些定义在该广义函数上的所有方法都必须接受的参数. <em>DEFGENERIC</em>应当总是带有的选项是 <em>:documentation</em>, 下面是一个广义函数:</p>
<div class="highlight"><pre><span class="p">(</span><span class="n">defgeneric</span> <span class="n">withdraw</span> <span class="p">(</span><span class="n">account</span> <span class="n">amount</span><span class="p">)</span>
  <span class="p">(</span><span class="o">:</span><span class="n">documentation</span> <span class="s">&quot;Withdraw&quot;</span><span class="p">))</span>
</pre></div>


<h2>DEFMETHOD</h2>
<p><em>DEFMETHOAD</em>用来定义实现广义函数的方法, 方法的形参列表必须与它的广义函数保持一致, 下面是一个实现了withdraw广义函数的方法</p>
<div class="highlight"><pre><span class="p">(</span><span class="n">defmethod</span> <span class="n">withdraw</span> <span class="p">((</span><span class="n">account</span> <span class="n">bank</span><span class="o">-</span><span class="n">account</span><span class="p">)</span> <span class="n">amount</span><span class="p">)</span>
  <span class="p">(</span><span class="n">when</span> <span class="p">(</span><span class="o">&lt;</span> <span class="p">(</span><span class="n">balance</span> <span class="n">account</span><span class="p">)</span> <span class="n">amount</span><span class="p">)</span>
    <span class="p">(</span><span class="n">error</span> <span class="s">&quot;Account overdrawn.&quot;</span><span class="p">))</span>
  <span class="p">(</span><span class="n">decf</span> <span class="p">(</span><span class="n">balance ...</span></pre></div> <a class="btn btn-info xsmall" href="http://blog.me/lispxue-xi-bi-ji-yan-yi-han-shu.html">read more</a></div>
    </div>	
				

 
        

 

    <div class='article'>
        <a href="http://blog.me/lisp-wen-jian-he-wen-jian-io.html"><h2>Lisp 文件和文件I/O</h2></a>
        <div class= "well small"> 四 28 三月 2013

by <a class="url fn" href="http://blog.me/author/coolnet.html">coolnet</a>
 


 </div>
        <div class="summary"><h2>读取文件数据</h2>
<p><em>OPEN</em>函数获取一个流并从中读取文件的内容.</p>
<p><em>READ-CHAR</em>读取单个字符, <em>READ-LINE</em>读取一行文本, 去掉行结束字符作为一个字符串返回, <em>READ</em>读取单一个S-表达式并返回一个Lisp对象.</p>
<p><em>CLOSE</em>函数用来关闭文件流</p>
<div class="highlight"><pre><span class="p">(</span><span class="n">let</span> <span class="p">((</span><span class="n">in</span> <span class="p">(</span><span class="n">open</span> <span class="s">&quot;/some/file/name.txt&quot;</span><span class="p">)))</span>
  <span class="p">(</span><span class="n">format</span> <span class="n">t</span> <span class="s">&quot;~a~%&quot;</span> <span class="p">(</span><span class="n">read</span><span class="o">-</span><span class="n">line</span> <span class="n">in</span><span class="p">))</span>
  <span class="p">(</span><span class="n">close</span> <span class="n">in</span><span class="p">))</span>
</pre></div>


<p>可以给<em>OPEN</em>指定关键字参数 <em>:if-does-not-exist_来指定打开文件不存在事的行为: </em>:error_, 报错(默认), <em>:create</em>, 继续进行并创建该文件, <em>NIL</em>, 让它返回<em>NIL</em>代替一个流</p>
<div class="highlight"><pre><span class="p">(</span><span class="n">let</span> <span class="p">((</span><span class="n">in</span> <span class="p">(</span><span class="n">open</span> <span class="s">&quot;/some/file/name.txt&quot;</span> <span class="o">:</span><span class="k">if</span><span class="o">-</span><span class="n">dos</span><span class="o">-</span><span class="n">not ...</span></pre></div> <a class="btn btn-info xsmall" href="http://blog.me/lisp-wen-jian-he-wen-jian-io.html">read more</a></div>
    </div>	
				

 
        

 

    <div class='article'>
        <a href="http://blog.me/dian-dui-dan-yuan-de-qi-ta-yong-fa.html"><h2>点对单元的其他用法</h2></a>
        <div class= "well small"> 四 28 三月 2013

by <a class="url fn" href="http://blog.me/author/coolnet.html">coolnet</a>
 


 </div>
        <div class="summary"><h2>树</h2>
<p>数结构是同时跟随<em>CAR</em>和<em>CDR</em>的引用, 只要它们指向其他点对单元, 树中的值就是该树结构中所有点对单元引用的非点对单元的值</p>
<h2>集合</h2>
<p>集合也可以用点对单元实现.<em>ADJOIN</em>函数用来构造集合, 它接受一个项和一个代表集合的列表并返回另一个代表集合的列表, 其中含有该项和原有集合中的所有项.它会扫描该列表, 如果没找到该项, 那么它会创建一个保存该项的新点对单元, 并让其指向原先的列表并返回它.否则, 它返回原先的列表</p>
<p><em>ADJOIN</em>也接受 <em>:key_和 </em>:test_关键字参数, 它们用于检测该项是否存在与原先类表中.</p>
<p><em>ADJON</em>不会影响原先列表, 如果打算修改将<em>ADJOIN</em>返回的值赋值到该列表所来自的位置上. <em>PUSHNEW</em>修改宏可以字段自动做到这点</p>
<div class="highlight"><pre><span class="p">(</span><span class="n">defparameter</span> <span class="o">*</span><span class="n">set</span><span class="o">*</span> <span class="p">())</span>       <span class="o">--&gt;</span>  <span class="o">*</span><span class="n">SET</span><span class="o">*</span>
<span class="p">(</span><span class="n">adjoin</span> <span class="mi">1</span> <span class="o">*</span><span class="n">set</span><span class="o">*</span><span class="p">)</span>              <span class="o">--&gt;</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="o">*</span><span class="n">set</span><span class="o">*</span>                         <span class="o">--&gt;</span> <span class="n">NIL</span> <span class="p">;;</span> <span class="err">因为不会修改源列表</span>
<span class="p">(</span><span class="n">setf</span> <span class="o">*</span><span class="n">set</span><span class="o">*</span> <span class="p">(</span><span class="n">adjion</span> <span class="mi">1</span> <span class="o">*</span><span class="n">set</span><span class="o">*</span><span class="p">))</span> <span class="o">--&gt;</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="o">*</span><span class="n">set</span><span class="o">*</span>                         <span class="o">--&gt;</span> <span class="p">(</span><span class="mi">1 ...</span></pre></div> <a class="btn btn-info xsmall" href="http://blog.me/dian-dui-dan-yuan-de-qi-ta-yong-fa.html">read more</a></div>
    </div>	
				

 
        

 

    <div class='article'>
        <a href="http://blog.me/lisp-xue-xi-bi-ji-ji-he.html"><h2>Lisp 学习笔记 ---- 集合</h2></a>
        <div class= "well small"> 一 25 三月 2013

by <a class="url fn" href="http://blog.me/author/coolnet.html">coolnet</a>
 


 </div>
        <div class="summary"><h2>向量</h2>
<p>向量是Common Lisp基本的整数索引集合, 它们分为两大类: 定长向量和变长向量</p>
<h3>定长向量</h3>
<p>定长向量是一个块数据头以及一段保存向量元素的连续内存区域</p>
<p>可以使用<em>VECTOR</em>来生成含有特定值的定长向量, 改函数接受任意数量的参数并返回一个新分配的含有那些参数的定长向量.</p>
<div class="highlight"><pre><span class="p">(</span><span class="n">vector</span><span class="p">)</span>  <span class="o">--&gt;</span> <span class="err">#</span><span class="p">()</span>
<span class="p">(</span><span class="n">vector</span> <span class="mi">1</span><span class="p">)</span> <span class="o">--&gt;</span> <span class="err">#</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="p">(</span><span class="n">vector</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">)</span> <span class="o">--&gt;</span> <span class="err">#</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>


<p><em>#(...)</em> 是向量的字面表达式, 该语法可以使用<em>PRINT</em>打印并用<em>READ</em>读取.也可以使用<em>#(...)</em>在代码中添加字面向量, 但修改字面对象的后果并不明确, 因此应当总是使用<em>VECTOR</em>或更为通用的函数<em>MAKE-ARRAY</em>来创建打算修改的向量</p>
<p><em>MAKE-ARRAY</em>比<em>VECTOR</em>更加通用, 因为它可以用来创建任何维度的数组以及定长和变量向量. <em>MAKE-ARRAY</em>的一个必要参数是一个含有数组维度的列表, 创建有初始化的向量可以传递 _:initial-element_参数:</p>
<div class="highlight"><pre><span class="p">(</span><span class="n">make</span><span class="o">-</span><span class="n">array</span> <span class="mi">5</span> <span class="o">:</span><span class="n">initial</span><span class="o">-</span><span class="n">element</span> <span class="n">nil ...</span></pre></div> <a class="btn btn-info xsmall" href="http://blog.me/lisp-xue-xi-bi-ji-ji-he.html">read more</a></div>
    </div>	
				

 
        

 

    <div class='article'>
        <a href="http://blog.me/lisp-xue-xi-bi-ji-hong.html"><h2>Lisp 学习笔记---宏</h2></a>
        <div class= "well small"> 四 21 三月 2013

by <a class="url fn" href="http://blog.me/author/coolnet.html">coolnet</a>
 


 </div>
        <div class="summary"><h2>宏</h2>
<p>前面介绍中其实<em>宏</em>的功能就是生成Lisp代码, <em>宏</em>就是编译器用来生成代码并随后编译的程序</p>
<h2>宏展开期和运行期</h2>
<p>只有当所有的<em>宏</em>都被完全展开并且产生的代码被编译后, 程序才可以实际运行.</p>
<p><em>宏</em> 运行的时期被成为<em>宏</em>展开期, 运行期指的是正常的代码(包括<em>宏</em>生成的代码) 实际运行阶段</p>
<p>运行期和展开期的代码运行的环境完全不同.<em>宏</em>展开期无法访问那些仅存在与运行期的数据.比如<em>WHEN</em>宏唯一可用的数据就是源代码.</p>
<h2>DEFMACRO</h2>
<p><em>宏</em>使用<em>DEFMACRO</em>来定义:</p>
<div class="highlight"><pre><span class="p">(</span><span class="n">defmacro</span> <span class="n">name</span> <span class="p">(</span><span class="n">parameter</span><span class="o">*</span><span class="p">)</span>
  <span class="s">&quot;Optional documentation string.&quot;</span>
  <span class="n">body</span><span class="o">-</span><span class="n">form</span><span class="o">*</span><span class="p">)</span>
</pre></div>


<p>和函数一样, 宏由名字、形参列表、可选文档字符串以及Lisp表达式体所构成.但宏并不是直接做事， 而是生成做事的代码。</p>
<h3>编写宏的步骤</h3>
<ol>
<li>编写示例的宏调用以及它应当展开的代码, 反之依然;</li>
<li>编写从示例调用的参数中生成手写展开是代码；</li>
<li>确保宏抽象不产生 ...</li></ol> <a class="btn btn-info xsmall" href="http://blog.me/lisp-xue-xi-bi-ji-hong.html">read more</a></div>
    </div>	
				

 
        

 

    <div class='article'>
        <a href="http://blog.me/lispxue-xi-bi-ji-hong-biao-zhun-kong-zhi-gou-zao.html"><h2>Lisp学习笔记---宏: 标准控制构造</h2></a>
        <div class= "well small"> 三 20 三月 2013

by <a class="url fn" href="http://blog.me/author/coolnet.html">coolnet</a>
 


 </div>
        <div class="summary"><h2>概述</h2>
<h3>IF</h3>
<p>所有<code>宏</code>都定义了自己的语法, 它们能够解决那些被传递的<code>S-表达式</code>如何能转换成Lisp形式.核心语言有了<code>宏</code>, 就能构造出新的语法, 诸如<code>WHEN</code> <code>DOLIST</code>和<code>LOOP</code>这样的控制构造以及<code>DEFUN</code>和<code>DEFPARAMETER</code>这样的定义形式.</p>
<h2>WHEN和UNLESS</h2>
<p>最基本的条件执行形式由<code>IF</code>特殊操作符提供, 其基本形式是: 如果<code>x</code>成立, 那么执行<code>y</code>, 否则执行<code>z</code></p>
<div class="highlight"><pre><span class="p">(</span><span class="k">if</span> <span class="n">condition</span> <span class="n">then</span><span class="o">-</span><span class="n">form</span> <span class="p">[</span><span class="k">else</span><span class="o">-</span><span class="n">form</span><span class="p">])</span>
</pre></div>


<h3>PROGN</h3>
<p>但是 <em>then-form</em> 和 <em>else-form</em> 都被限制必须是单一的Lisp形式, 但是特殊操作符 <em>PROGN</em> 可以按顺序执行任意数量的表达式并返回最后一个表达式的值</p>
<div class="highlight"><pre><span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="n">spam ...</span></pre></div> <a class="btn btn-info xsmall" href="http://blog.me/lispxue-xi-bi-ji-hong-biao-zhun-kong-zhi-gou-zao.html">read more</a></div>
    </div>	
				

 
        

 

    <div class='article'>
        <a href="http://blog.me/lisp-xue-xi-bi-ji-bian-liang.html"><h2>Lisp 学习笔记----变量</h2></a>
        <div class= "well small"> 三 20 三月 2013

by <a class="url fn" href="http://blog.me/author/coolnet.html">coolnet</a>
 


 </div>
        <div class="summary"><h2>概述</h2>
<p>Common Lisp的变量是一些可以保存值的具名位置.Common Lisp支持两种类型的变量:<code>词法(lexical)变量</code>和<code>动态(dynamic)变量</code>分别对应其他语言中的<code>局部变量</code>和全局变量.<code>动态变量</code>有时也被成为<code>特殊变量</code>.Common Lisp中所有值都是对像的引用, 如果一个变量保存了对一个可变对象的应用,那么就可以用改引用来修改此对象(Python就借鉴于此)</p>
<h3>LET</h3>
<p>引入新变量的另一种方式就是使用<code>LET</code>操作符:</p>
<div class="highlight"><pre><span class="p">(</span><span class="n">let</span> <span class="p">(</span><span class="n">variable</span><span class="o">*</span><span class="p">)</span> <span class="n">body</span><span class="o">-</span><span class="n">form</span><span class="o">*</span><span class="p">)</span>
</pre></div>


<p>其中每一<code>variable</code>都是一个变量初始化形式.每一个初始化要么是一个含有变量名的初值形式列表, 要么就是一个简单的变量名---变量被初始化为<code>NIL</code></p>
<div class="highlight"><pre><span class="p">(</span><span class="n">let</span> <span class="p">((</span><span class="n">x</span> <span class="mi">10</span><span class="p">)</span> <span class="p">(</span><span class="n">y</span> <span class="mi">20</span><span class="p">)</span> <span class="n">z</span><span class="p">)</span>
<span class="p">...)</span>
</pre></div>


<p>上面将会为所有的初始值形式求值,然后创建出新的绑定,并在形式体被执行之前这些绑定将初始化到适当的初始值上.在<code>LET</code>形式体中,变量名将引用新创建的绑定 ...</p> <a class="btn btn-info xsmall" href="http://blog.me/lisp-xue-xi-bi-ji-bian-liang.html">read more</a></div>
    </div>	
				

 
        

 

    <div class='article'>
        <a href="http://blog.me/lisp-xue-xi-bi-ji.html"><h2>Lisp 学习笔记</h2></a>
        <div class= "well small"> 二 19 三月 2013

by <a class="url fn" href="http://blog.me/author/coolnet.html">coolnet</a>
 


 </div>
        <div class="summary"><h2>数据结构</h2>
<h3>list</h3>
<p>LIST 函数生成一个由其参数组成的列表</p>
<div class="highlight"><pre><span class="n">CL</span><span class="o">-</span><span class="n">USER</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">list</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span>
<span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>


<h3>plist</h3>
<p>属性列表(Property List)可以将列表中的给定位置映射到纪录中的给定字段(相当于hash表, 但是并不是真正的hash表)</p>
<div class="highlight"><pre><span class="n">CL</span><span class="o">-</span><span class="n">USER</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">list</span> <span class="o">:</span><span class="n">a</span> <span class="mi">1</span> <span class="o">:</span><span class="n">b</span> <span class="mi">2</span> <span class="o">:</span><span class="n">c</span> <span class="mi">3</span><span class="p">)</span>
<span class="p">(</span><span class="o">:</span><span class="n">A</span> <span class="mi">1</span> <span class="o">:</span><span class="n">B</span> <span class="mi">2</span> <span class="o">:</span><span class="n">C</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>


<p>plist 和使用创建普通列表的函数只是改变参数来实现</p>
<h2>变量</h2>
<h3>定义</h3>
<p>Lisp使用<code>DEFVAR</code>宏来定义变量.如果定义全局变量需用<code>*</code>来命名, 比如:</p>
<div class="highlight"><pre><span class="p">(</span><span class="n">defvar</span> <span class="o">*</span><span class="n">db</span><span class="o">*</span> <span class="n">nil</span><span class="p">)</span> <span class="p">;</span> <span class="err">定义</span><span class="o">*</span><span class="n">db ...</span></pre></div> <a class="btn btn-info xsmall" href="http://blog.me/lisp-xue-xi-bi-ji.html">read more</a></div>
    </div>	
				

 
        

 

    <div class='article'>
        <a href="http://blog.me/lispyu-fa-xue-xi-bi-ji.html"><h2>Lisp语法学习笔记</h2></a>
        <div class= "well small"> 二 19 三月 2013

by <a class="url fn" href="http://blog.me/author/coolnet.html">coolnet</a>
 


 </div>
        <div class="summary"><h2>特殊操作符</h2>
<p>Common Lisp定义了一些特殊的操作符, 它们可以做到函数无法做到的事情</p>
<h3>IF</h3>
<p><code>IF</code>的规则相当简单: 求值第一个表达式.如果第一个表达式得到非<code>NIL</code>则求值第二个表达式并返回它的值否则返回第三个表达式的值或者没有第三个表达式的话返回<code>NIL</code></p>
<div class="highlight"><pre><span class="p">(</span><span class="k">if</span> <span class="n">test</span><span class="o">-</span><span class="n">form</span> <span class="n">then</span><span class="o">-</span><span class="n">form</span> <span class="p">[</span> <span class="k">else</span><span class="o">-</span><span class="n">form</span> <span class="p">])</span>
</pre></div>


<h3>QUOTE</h3>
<p><code>QUOTE</code>接受一个单衣表达式作为其<code>参数</code>并简单的返回它:</p>
<div class="highlight"><pre><span class="p">(</span><span class="n">quote</span> <span class="p">(</span><span class="o">+</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">))</span>  <span class="o">--&gt;</span> <span class="p">(</span><span class="o">+</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>


<p>同时可以用下面的方式简写上面的表达式</p>
<div class="highlight"><pre><span class="err">&#39;</span><span class="p">(</span><span class="o">+</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">)</span>      <span class="o">--&gt;</span> <span class="p">(</span><span class="o">+</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>


<h3>LET</h3>
<p><code>LET</code>用来创建新的变量绑定</p>
<div class="highlight"><pre><span class="p">(</span><span class="n">let</span> <span class="p">((</span><span class="n">x</span> <span class="mi">10</span><span class="p">))</span> <span class="n">x</span><span class="p">)</span>  <span class="o">--&gt;</span> <span class="mi">10</span>
</pre></div>


<h2>真假和等价</h2>
<p>符号<code>NIL</code>是唯一的假值,其他所有都是真值.<code>NIL</code>是唯一一个及时原子有是列表的对象:除了用来表示真假外 ...</p> <a class="btn btn-info xsmall" href="http://blog.me/lispyu-fa-xue-xi-bi-ji.html">read more</a></div>
    </div>	
				
<div class="pagination">
<ul>
    <li class="prev disabled"><a href="#">&larr; Previous</a></li>

    <li class="active"><a href="http://blog.me/category/lisp.html">1</a></li>

    <li class="next disabled"><a href="#">&rarr; Next</a></li>

</ul>
</div>
 
  
        </div>
        
        <div class="span3">

            <div class="well" style="padding: 8px 0; background-color: #FBFBFB;">
            <ul class="nav nav-list">
                <li class="nav-header"> 
                Site
                </li>
            
                <li><a href="http://blog.me/archives.html">Archives</a>
                <li><a href="http://blog.me/tags.html">Tags</a>
                <li><a href="http://blog.me/feeds/all.atom.xml" rel="alternate">Atom feed</a></li>
            </ul>
            </div>


            <div class="well" style="padding: 8px 0; background-color: #FBFBFB;">
            <ul class="nav nav-list">
                <li class="nav-header"> 
                Categories
                </li>
                
                <li><a href="http://blog.me/category/bar.html">bar</a></li>
                <li><a href="http://blog.me/category/cat1.html">cat1</a></li>
                <li><a href="http://blog.me/category/content.html">content</a></li>
                <li><a href="http://blog.me/category/han-shu.html">函数</a></li>
                <li><a href="http://blog.me/category/linux.html">Linux</a></li>
                <li><a href="http://blog.me/category/lisp.html">Lisp</a></li>
                <li><a href="http://blog.me/category/test_data.html">test_data</a></li>
                <li><a href="http://blog.me/category/yeah.html">yeah</a></li>
                   
            </ul>
            </div>


            <div class="well" style="padding: 8px 0; background-color: #FBFBFB;">
            <ul class="nav nav-list">
                <li class="nav-header"> 
                Links
                </li>
            
                <li><a href="http://eleveni386.7axu.com">eleven</a></li>
                <li><a href="http://neteue.com">小邪兽_deepin</a></li>
                <li><a href="http://frantic1048.com/">Frantic1048</a></li>
                <li><a href="http://www.dongxf.com/">晓风'Blog</a></li>
            </ul>
            </div>



        </div>  
    </div>     </div> 
<footer>
<br />
<p><a href="http://blog.me">coolnet's world</a> &copy; coolnet 2013
    <script src="http://s96.cnzz.com/stat.php?id=3767683&web_id=3767683&show=pic" language="JavaScript"></script>
</p>
</footer>

</div> <!-- /container -->
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
<script src="http://twitter.github.com/bootstrap/assets/js/bootstrap-collapse.js"></script>
<a href="https://github.com/batcom/coldnight.github.com"><img style="position: absolute; top: 40px; right: 0; border: 0;" src="http://s3.amazonaws.com/github/ribbons/forkme_right_white_ffffff.png" alt="Fork me on GitHub" /></a>
 
</body>
</html>